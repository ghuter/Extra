#!/bin/sh

#----------------------------------------------------------------------------------
# Project Name      - Extra/lspkg (List Packages)
# Started On	    - Sun 17 Sep 04:13:30 BST 2017
# Last Change       - Thu  5 Dec 20:23:56 GMT 2019
# Author E-Mail     - terminalforlife@yahoo.com
# Author GitHub     - https://github.com/terminalforlife
#----------------------------------------------------------------------------------

CurVer='2019-12-05'
Progrm=${0##*/}

#TODO - The ignore case flag won't work when specifying glob matching.
#TODO - Add ability to search only the whole word, like `STRING`, not `*STRING*`.

Err(){
	printf "ERROR: %s\n" "$2" 1>&2
	[ $1 -gt 0 ] && exit $1
}

StatusFile='/var/lib/dpkg/status'

Usage(){
	while read; do
		printf "%s\n" "$REPLY"
	done <<-EOF
		            LSPKG ($CurVer)
		            Written by terminalforlife (terminalforlife@yahoo.com)

		            Search through, test for, and list out installed packages.

		SYNTAX:     $Progrm [OPTS] [SEARCH_1 [SEARCH_2] ...]

		OPTS:       --help|-h|-?            - Displays this help information.
		            --version|-v            - Output only the version datestamp.
		            --debug|-D              - Enables the built-in bash debugging.
		            --no-describe|-N        - Do not display package descriptions.
		            --name-only|-n          - Match only the package names.
		            --ignore-case|-i        - Match both upper- and lower-case.
		            --show-arch|-a          - Include package arch-types.
		            --count|-c              - Display the total number of packages.

		NOTE:       This shell program is only compatible with Debian or Ubuntu based
		            systems, as it parses dpkg-query's output.

		            Where SEARCH is an optional glob match of an installed package. By
		            default, the match will be looked for on the whole line, which includes
		            the package name and its short description, like apt-cache search.

		            If you include --name-only or -n, then the match will be looked for
		            only in the name, like apt-cache -n search. This is to keep the
		            behavior predictable and easy to use.

		            Using --show-arch|-s allows for those with a package for both
		            architectures to be shown, instead of just one; this could account
		            for any inconsistencies if the package count were checked manually.

		            An exit status of 4 means no match(es) were found.

		FILE:       $StatusFile
	EOF
}

while [ "$1" ]; do
	case $1 in
		--help|-h|-\?)
			Usage; exit 0 ;;
		--version|-v)
			printf "%s\n" "$CurVer"
			exit 0 ;;
		--debug|-D)
			DebugMe='true' ;;
		--no-describe|-N)
			NoDesc='true' ;;
		--ignore-case|-i)
			CaseInsensitive='true' ;;
		--name-only|-n)
			NameOnly='true' ;;
		--show-arch|-a)
			ShowArch='true' ;;
		--count|-c)
			DOCount='true' ;;
		-*)
			Err 1 $LINENO "Incorrect argument(s) specified." ;;
		*)
			break ;;
	esac
	shift
done

[ "$DebugMe" == 'true' ] && set -x

while read Key Value _; do
	case $Key in
		Package:)
			while [ "$1" ]; do
				case $1 in
					"|$@") [ "$CurPKG" = "$Value" ] || continue 2
				shift
			done

			Package=$Value ;;
		Architecture:)
			[ "$ShowArch" = 'true' ] && Arch=":$Value" ;;
		Status:)
			[ "$Value $_" = 'install ok installed' ] || continue ;;
		Description:)
			Desc="$Value $_" ;;
		''|*)
			continue ;;
	esac

	if ! [ "$Package" = "$OldPackage" ]; then
		printf "%s%s - %s\n" "$Package" "$Arch" "$Desc"
	fi

	OldPackage=$Package
done < "$StatusFile"

#declare -i Count=0
#declare -i SearchResult=0
#while read -a CurLine; do
#	if ! [ "$ShowArch" == 'true' ]; then
#		# Remove duplicate entries. This works because dpkg-query is outputting in
#		# alphabetical order, else this would surely be useless.
#		[ "${CurLine[1]}" == "$Old" ] && continue
#	fi
#
#	if [ "${CurLine[0]}" == "ii" ]; then
#		unset Buffer
#		Count+=1
#
#		# No new line character as this is an array. Otherwise every word
#		# would print on a new line. The final new line is added when the
#		# text is displayed on the screen with echo.
#		printf -v Buffer "%s " ${CurLine[@]/ii}
#		[ "$Buffer" ] || continue
#
#		# If there are user-specified matches to find, then iterate over
#		# them by checking to see if each current package matches each one
#		# in the list of ones the user specified.
#		if [ -n "$1" ]; then
#			USER_SEARCH='true'
#
#			for P in "$@"; {
#				if [ "$NameOnly" == 'true' ]; then
#					Filter=" ${CurLine[1]}"
#				else
#					Filter=${CurLine[@]/ii}
#				fi
#
#				case ${MatchWith:-UNSET} in
#					glob)
#						if [[ $Filter == " "$P ]]; then
#							Match "${Buffer% }"
#						fi ;;
#					regex|*)
#						if [[ $Filter =~ ${P/^/^ } ]]; then
#							Match "${Buffer% }"
#						fi ;;
#				esac
#			}
#		else
#			# If there are no packages specified by the user, just show
#			# all of the packages. Removing the space because of the
#			# above printf command adding a trailing space.
#			if ! [ "$NoDesc" == 'true' ]; then
#				printf "%s\n" "${Buffer% }"
#			else
#				printf "%s\n" "${Buffer%% - *}"
#			fi
#		fi
#
#		if ! [ "$ShowArch" == 'true' ]; then
#			# Save the current value to be checked when the next
#			# package is processed.
#			Old=${CurLine[1]}
#		fi
#	fi
#done <<< "$(PKGList)"
#
## Just in-case a later feature added below uses globs.
#[ "$CaseInsensitive" == 'true' ] && shopt -u nocaseglob
#
#if [ "$DOCount" == 'true' ]; then
#	if ! [ "$USER_SEARCH" == 'true' ]; then
#		printf "\nTOTAL: %'d\n" "$Count"
#	else
#		[ $SearchResult -eq 0 ] && S= || S="\n"
#		printf "${S}TOTAL: %'d/%'d\n" "$SearchResult" "$Count"
#	fi
#fi
#
#if [ "$*" -a ! $SearchResult -gt 0 ]; then
#	exit 4
#fi
